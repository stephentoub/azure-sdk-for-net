// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Collections.Generic;
using System.Linq;
using Azure.Core.Expressions.DataFactory;

namespace BasicTypeSpec
{
    /// <summary> A factory class for creating instances of the models for mocking. </summary>
    public static partial class BasicTypeSpecModelFactory
    {
        /// <summary> A model with a few properties of literal types. </summary>
        /// <param name="name"> name of the ThingModel. </param>
        /// <param name="requiredUnion"> required Union. </param>
        /// <param name="optionalLiteralString"> optional literal string. </param>
        /// <param name="optionalLiteralInt"> optional literal int. </param>
        /// <param name="optionalLiteralFloat"> optional literal float. </param>
        /// <param name="optionalLiteralBool"> optional literal bool. </param>
        /// <param name="requiredBadDescription"> description with xml &lt;|endoftext|&gt;. </param>
        /// <param name="optionalNullableList"> optional nullable collection. </param>
        /// <param name="requiredNullableList"> required nullable collection. </param>
        /// <returns> A new <see cref="BasicTypeSpec.ThingModel"/> instance for mocking. </returns>
        public static ThingModel ThingModel(string name = default, BinaryData requiredUnion = default, ThingModelOptionalLiteralString? optionalLiteralString = default, ThingModelOptionalLiteralInt? optionalLiteralInt = default, ThingModelOptionalLiteralFloat? optionalLiteralFloat = default, bool? optionalLiteralBool = default, string requiredBadDescription = default, IEnumerable<int> optionalNullableList = default, IEnumerable<int> requiredNullableList = default)
        {
            optionalNullableList ??= new ChangeTrackingList<int>();
            requiredNullableList ??= new ChangeTrackingList<int>();

            return new ThingModel(
                name,
                requiredUnion,
                "accept",
                123,
                1.23F,
                false,
                optionalLiteralString,
                optionalLiteralInt,
                optionalLiteralFloat,
                optionalLiteralBool,
                requiredBadDescription,
                optionalNullableList.ToList(),
                requiredNullableList.ToList(),
                additionalBinaryDataProperties: null);
        }

        /// <summary> this is a roundtrip model. </summary>
        /// <param name="requiredString"> Required string, illustrating a reference type property. </param>
        /// <param name="requiredInt"> Required int, illustrating a value type property. </param>
        /// <param name="requiredCollection"> Required collection of enums. </param>
        /// <param name="requiredDictionary"> Required dictionary of enums. </param>
        /// <param name="requiredModel"> Required model. </param>
        /// <param name="intExtensibleEnum"> this is an int based extensible enum. </param>
        /// <param name="intExtensibleEnumCollection"> this is a collection of int based extensible enum. </param>
        /// <param name="floatExtensibleEnum"> this is a float based extensible enum. </param>
        /// <param name="floatExtensibleEnumWithIntValue"> this is a float based extensible enum. </param>
        /// <param name="floatExtensibleEnumCollection"> this is a collection of float based extensible enum. </param>
        /// <param name="floatFixedEnum"> this is a float based fixed enum. </param>
        /// <param name="floatFixedEnumWithIntValue"> this is a float based fixed enum. </param>
        /// <param name="floatFixedEnumCollection"> this is a collection of float based fixed enum. </param>
        /// <param name="intFixedEnum"> this is a int based fixed enum. </param>
        /// <param name="intFixedEnumCollection"> this is a collection of int based fixed enum. </param>
        /// <param name="stringFixedEnum"> this is a string based fixed enum. </param>
        /// <param name="requiredUnknown"> required unknown. </param>
        /// <param name="optionalUnknown"> optional unknown. </param>
        /// <param name="requiredRecordUnknown"> required record of unknown. </param>
        /// <param name="optionalRecordUnknown"> optional record of unknown. </param>
        /// <param name="readOnlyRequiredRecordUnknown"> required readonly record of unknown. </param>
        /// <param name="readOnlyOptionalRecordUnknown"> optional readonly record of unknown. </param>
        /// <param name="modelWithRequiredNullable"> this is a model with required nullable properties. </param>
        /// <param name="requiredBytes"> Required bytes. </param>
        /// <returns> A new <see cref="BasicTypeSpec.RoundTripModel"/> instance for mocking. </returns>
        public static RoundTripModel RoundTripModel(string requiredString = default, int requiredInt = default, IEnumerable<StringFixedEnum> requiredCollection = default, IDictionary<string, StringExtensibleEnum> requiredDictionary = default, ThingModel requiredModel = default, IntExtensibleEnum? intExtensibleEnum = default, IEnumerable<IntExtensibleEnum> intExtensibleEnumCollection = default, FloatExtensibleEnum? floatExtensibleEnum = default, FloatExtensibleEnumWithIntValue? floatExtensibleEnumWithIntValue = default, IEnumerable<FloatExtensibleEnum> floatExtensibleEnumCollection = default, FloatFixedEnum? floatFixedEnum = default, FloatFixedEnumWithIntValue? floatFixedEnumWithIntValue = default, IEnumerable<FloatFixedEnum> floatFixedEnumCollection = default, IntFixedEnum? intFixedEnum = default, IEnumerable<IntFixedEnum> intFixedEnumCollection = default, StringFixedEnum? stringFixedEnum = default, BinaryData requiredUnknown = default, BinaryData optionalUnknown = default, IDictionary<string, BinaryData> requiredRecordUnknown = default, IDictionary<string, BinaryData> optionalRecordUnknown = default, IReadOnlyDictionary<string, BinaryData> readOnlyRequiredRecordUnknown = default, IReadOnlyDictionary<string, BinaryData> readOnlyOptionalRecordUnknown = default, ModelWithRequiredNullableProperties modelWithRequiredNullable = default, BinaryData requiredBytes = default)
        {
            requiredCollection ??= new ChangeTrackingList<StringFixedEnum>();
            requiredDictionary ??= new ChangeTrackingDictionary<string, StringExtensibleEnum>();
            intExtensibleEnumCollection ??= new ChangeTrackingList<IntExtensibleEnum>();
            floatExtensibleEnumCollection ??= new ChangeTrackingList<FloatExtensibleEnum>();
            floatFixedEnumCollection ??= new ChangeTrackingList<FloatFixedEnum>();
            intFixedEnumCollection ??= new ChangeTrackingList<IntFixedEnum>();
            requiredRecordUnknown ??= new ChangeTrackingDictionary<string, BinaryData>();
            optionalRecordUnknown ??= new ChangeTrackingDictionary<string, BinaryData>();
            readOnlyRequiredRecordUnknown ??= new ChangeTrackingDictionary<string, BinaryData>();
            readOnlyOptionalRecordUnknown ??= new ChangeTrackingDictionary<string, BinaryData>();

            return new RoundTripModel(
                requiredString,
                requiredInt,
                requiredCollection.ToList(),
                requiredDictionary,
                requiredModel,
                intExtensibleEnum,
                intExtensibleEnumCollection.ToList(),
                floatExtensibleEnum,
                floatExtensibleEnumWithIntValue,
                floatExtensibleEnumCollection.ToList(),
                floatFixedEnum,
                floatFixedEnumWithIntValue,
                floatFixedEnumCollection.ToList(),
                intFixedEnum,
                intFixedEnumCollection.ToList(),
                stringFixedEnum,
                requiredUnknown,
                optionalUnknown,
                requiredRecordUnknown,
                optionalRecordUnknown,
                readOnlyRequiredRecordUnknown,
                readOnlyOptionalRecordUnknown,
                modelWithRequiredNullable,
                requiredBytes,
                additionalBinaryDataProperties: null);
        }

        /// <summary> A model with a few required nullable properties. </summary>
        /// <param name="requiredNullablePrimitive"> required nullable primitive type. </param>
        /// <param name="requiredExtensibleEnum"> required nullable extensible enum type. </param>
        /// <param name="requiredFixedEnum"> required nullable fixed enum type. </param>
        /// <returns> A new <see cref="BasicTypeSpec.ModelWithRequiredNullableProperties"/> instance for mocking. </returns>
        public static ModelWithRequiredNullableProperties ModelWithRequiredNullableProperties(int? requiredNullablePrimitive = default, StringExtensibleEnum? requiredExtensibleEnum = default, StringFixedEnum? requiredFixedEnum = default)
        {
            return new ModelWithRequiredNullableProperties(requiredNullablePrimitive, requiredExtensibleEnum, requiredFixedEnum, additionalBinaryDataProperties: null);
        }

        /// <summary> this is not a friendly model but with a friendly name. </summary>
        /// <param name="name"> name of the NotFriend. </param>
        /// <returns> A new <see cref="BasicTypeSpec.FriendModel"/> instance for mocking. </returns>
        public static FriendModel FriendModel(string name = default)
        {
            return new FriendModel(name, additionalBinaryDataProperties: null);
        }

        /// <summary> this is a model with a client name. </summary>
        /// <param name="name"> name of the ModelWithClientName. </param>
        /// <returns> A new <see cref="BasicTypeSpec.RenamedModel"/> instance for mocking. </returns>
        public static RenamedModel RenamedModel(string name = default)
        {
            return new RenamedModel(name, additionalBinaryDataProperties: null);
        }

        /// <summary> The ReturnsAnonymousModelResponse. </summary>
        /// <returns> A new <see cref="BasicTypeSpec.ReturnsAnonymousModelResponse"/> instance for mocking. </returns>
        public static ReturnsAnonymousModelResponse ReturnsAnonymousModelResponse()
        {
            return new ReturnsAnonymousModelResponse(additionalBinaryDataProperties: null);
        }

        /// <summary> Model with DataFactoryElement properties. </summary>
        /// <param name="stringProperty"> String property with DFE pattern. </param>
        /// <param name="intProperty"> Int property with DFE pattern. </param>
        /// <param name="boolProperty"> Bool property with DFE pattern. </param>
        /// <param name="stringArrayProperty"> String array property with DFE pattern. </param>
        /// <returns> A new <see cref="BasicTypeSpec.DataFactoryElementModel"/> instance for mocking. </returns>
        public static DataFactoryElementModel DataFactoryElementModel(DataFactoryElement<string> stringProperty = default, DataFactoryElement<int> intProperty = default, DataFactoryElement<bool> boolProperty = default, DataFactoryElement<IList<string>> stringArrayProperty = default)
        {
            return new DataFactoryElementModel(stringProperty, intProperty, boolProperty, stringArrayProperty, additionalBinaryDataProperties: null);
        }

        /// <summary> An advanced XML model for testing various property types and XML features. </summary>
        /// <param name="name"> A simple string property. </param>
        /// <param name="age"> An integer property. </param>
        /// <param name="enabled"> A boolean property. </param>
        /// <param name="score"> A float property. </param>
        /// <param name="optionalString"> An optional string. </param>
        /// <param name="optionalInt"> An optional integer. </param>
        /// <param name="nullableString"> A nullable string. </param>
        /// <param name="id"> A string as XML attribute. </param>
        /// <param name="version"> An integer as XML attribute. </param>
        /// <param name="isActive"> A boolean as XML attribute. </param>
        /// <param name="originalName"> A property with a custom XML element name. </param>
        /// <param name="xmlIdentifier"> An attribute with a custom XML name. </param>
        /// <param name="content"> Text content in the element (unwrapped string). </param>
        /// <param name="unwrappedStrings"> An unwrapped array of strings - items appear directly without wrapper. </param>
        /// <param name="unwrappedCounts"> An unwrapped array of integers. </param>
        /// <param name="unwrappedItems"> An unwrapped array of models. </param>
        /// <param name="wrappedColors"> A wrapped array of strings (default). </param>
        /// <param name="items"> A wrapped array with custom wrapper name. </param>
        /// <param name="nestedModel"> A nested model property. </param>
        /// <param name="optionalNestedModel"> An optional nested model. </param>
        /// <param name="metadata"> A dictionary property. </param>
        /// <param name="createdAt"> A date-time property. </param>
        /// <param name="duration"> A duration property. </param>
        /// <param name="data"> A bytes property. </param>
        /// <param name="optionalRecordUnknown"> optional record of unknown. </param>
        /// <param name="fixedEnum"> A fixed enum property. </param>
        /// <param name="extensibleEnum"> An extensible enum property. </param>
        /// <param name="optionalFixedEnum"> An optional fixed enum property. </param>
        /// <param name="optionalExtensibleEnum"> An optional extensible enum property. </param>
        /// <param name="label"></param>
        /// <param name="daysUsed"></param>
        /// <param name="fooItems"></param>
        /// <param name="anotherModel"></param>
        /// <param name="modelsWithNamespaces"></param>
        /// <param name="unwrappedModelsWithNamespaces"></param>
        /// <param name="listOfListFoo"></param>
        /// <param name="dictionaryFoo"></param>
        /// <param name="dictionaryOfDictionaryFoo"></param>
        /// <param name="dictionaryListFoo"></param>
        /// <param name="listOfDictionaryFoo"></param>
        /// <returns> A new <see cref="BasicTypeSpec.XmlAdvancedModel"/> instance for mocking. </returns>
        public static XmlAdvancedModel XmlAdvancedModel(string name = default, int age = default, bool enabled = default, float score = default, string optionalString = default, int? optionalInt = default, string nullableString = default, string id = default, int version = default, bool isActive = default, string originalName = default, string xmlIdentifier = default, string content = default, IEnumerable<string> unwrappedStrings = default, IEnumerable<int> unwrappedCounts = default, IEnumerable<XmlItem> unwrappedItems = default, IEnumerable<string> wrappedColors = default, IEnumerable<XmlItem> items = default, XmlNestedModel nestedModel = default, XmlNestedModel optionalNestedModel = default, IDictionary<string, string> metadata = default, DateTimeOffset createdAt = default, TimeSpan duration = default, BinaryData data = default, IDictionary<string, BinaryData> optionalRecordUnknown = default, StringFixedEnum fixedEnum = default, StringExtensibleEnum extensibleEnum = default, IntFixedEnum? optionalFixedEnum = default, IntExtensibleEnum? optionalExtensibleEnum = default, string label = default, int daysUsed = default, IEnumerable<string> fooItems = default, XmlNestedModel anotherModel = default, IEnumerable<XmlModelWithNamespace> modelsWithNamespaces = default, IEnumerable<XmlModelWithNamespace> unwrappedModelsWithNamespaces = default, IEnumerable<IList<XmlItem>> listOfListFoo = default, IDictionary<string, XmlItem> dictionaryFoo = default, IDictionary<string, IDictionary<string, XmlItem>> dictionaryOfDictionaryFoo = default, IDictionary<string, IList<XmlItem>> dictionaryListFoo = default, IEnumerable<IDictionary<string, XmlItem>> listOfDictionaryFoo = default)
        {
            unwrappedStrings ??= new ChangeTrackingList<string>();
            unwrappedCounts ??= new ChangeTrackingList<int>();
            unwrappedItems ??= new ChangeTrackingList<XmlItem>();
            wrappedColors ??= new ChangeTrackingList<string>();
            items ??= new ChangeTrackingList<XmlItem>();
            metadata ??= new ChangeTrackingDictionary<string, string>();
            optionalRecordUnknown ??= new ChangeTrackingDictionary<string, BinaryData>();
            fooItems ??= new ChangeTrackingList<string>();
            modelsWithNamespaces ??= new ChangeTrackingList<XmlModelWithNamespace>();
            unwrappedModelsWithNamespaces ??= new ChangeTrackingList<XmlModelWithNamespace>();
            listOfListFoo ??= new ChangeTrackingList<IList<XmlItem>>();
            dictionaryFoo ??= new ChangeTrackingDictionary<string, XmlItem>();
            dictionaryOfDictionaryFoo ??= new ChangeTrackingDictionary<string, IDictionary<string, XmlItem>>();
            dictionaryListFoo ??= new ChangeTrackingDictionary<string, IList<XmlItem>>();
            listOfDictionaryFoo ??= new ChangeTrackingList<IDictionary<string, XmlItem>>();

            return new XmlAdvancedModel(
                name,
                age,
                enabled,
                score,
                optionalString,
                optionalInt,
                nullableString,
                id,
                version,
                isActive,
                originalName,
                xmlIdentifier,
                content,
                unwrappedStrings.ToList(),
                unwrappedCounts.ToList(),
                unwrappedItems.ToList(),
                wrappedColors.ToList(),
                items.ToList(),
                nestedModel,
                optionalNestedModel,
                metadata,
                createdAt,
                duration,
                data,
                optionalRecordUnknown,
                fixedEnum,
                extensibleEnum,
                optionalFixedEnum,
                optionalExtensibleEnum,
                label,
                daysUsed,
                fooItems.ToList(),
                anotherModel,
                modelsWithNamespaces.ToList(),
                unwrappedModelsWithNamespaces.ToList(),
                listOfListFoo.ToList(),
                dictionaryFoo,
                dictionaryOfDictionaryFoo,
                dictionaryListFoo,
                listOfDictionaryFoo.ToList(),
                additionalBinaryDataProperties: null);
        }

        /// <summary> An item model for XML array testing. </summary>
        /// <param name="itemName"> The item name. </param>
        /// <param name="itemValue"> The item value. </param>
        /// <param name="itemId"> Item ID as attribute. </param>
        /// <returns> A new <see cref="BasicTypeSpec.XmlItem"/> instance for mocking. </returns>
        public static XmlItem XmlItem(string itemName = default, int itemValue = default, string itemId = default)
        {
            return new XmlItem(itemName, itemValue, itemId, additionalBinaryDataProperties: null);
        }

        /// <summary> A nested model for XML testing. </summary>
        /// <param name="value"> The value of the nested model. </param>
        /// <param name="nestedId"> An attribute on the nested model. </param>
        /// <returns> A new <see cref="BasicTypeSpec.XmlNestedModel"/> instance for mocking. </returns>
        public static XmlNestedModel XmlNestedModel(string value = default, int nestedId = default)
        {
            return new XmlNestedModel(value, nestedId, additionalBinaryDataProperties: null);
        }

        /// <summary> The XmlModelWithNamespace. </summary>
        /// <param name="foo"></param>
        /// <returns> A new <see cref="BasicTypeSpec.XmlModelWithNamespace"/> instance for mocking. </returns>
        public static XmlModelWithNamespace XmlModelWithNamespace(string foo = default)
        {
            return new XmlModelWithNamespace(foo, additionalBinaryDataProperties: null);
        }

        /// <summary> Tree is a specific type of plant. </summary>
        /// <param name="id"> The unique identifier of the plant. </param>
        /// <param name="height"> The height of the plant in centimeters. </param>
        /// <param name="age"> The age of the tree in years. </param>
        /// <returns> A new <see cref="BasicTypeSpec.Tree"/> instance for mocking. </returns>
        public static Tree Tree(string id = default, int height = default, int age = default)
        {
            return new Tree("tree", id, height, additionalBinaryDataProperties: null, age);
        }

        /// <summary>
        /// Base plant with discriminator
        /// Please note this is the abstract base class. The derived classes available for instantiation are: <see cref="BasicTypeSpec.Tree"/>.
        /// </summary>
        /// <param name="species"> The species of plant. </param>
        /// <param name="id"> The unique identifier of the plant. </param>
        /// <param name="height"> The height of the plant in centimeters. </param>
        /// <returns> A new <see cref="BasicTypeSpec.Plant"/> instance for mocking. </returns>
        public static Plant Plant(string species = default, string id = default, int height = default)
        {
            return new UnknownPlant(species, id, height, additionalBinaryDataProperties: null);
        }
    }
}
