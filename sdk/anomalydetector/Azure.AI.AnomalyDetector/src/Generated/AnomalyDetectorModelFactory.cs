// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Collections.Generic;
using System.Linq;

namespace Azure.AI.AnomalyDetector
{
    /// <summary> A factory class for creating instances of the models for mocking. </summary>
    public static partial class AnomalyDetectorModelFactory
    {
        /// <summary> Request of the entire or last anomaly detection. </summary>
        /// <param name="series">
        /// Time series data points. Points should be sorted by time stamp in ascending
        /// order to match the anomaly detection result. If the data is not sorted
        /// correctly or there's a duplicated time stamp, the API won't work. In such
        /// a case, an error message is returned.
        /// </param>
        /// <param name="granularity">
        /// Argument that indicates time granularity. If granularity is not present, the value
        /// is none by default. If granularity is none, the time stamp property in the time
        /// series point can be absent.
        /// </param>
        /// <param name="customInterval">
        /// A custom interval is used to set a nonstandard time interval. For example, if the
        /// series is 5 minutes, the request can be set as {"granularity":"minutely",
        /// "customInterval":5}.
        /// </param>
        /// <param name="period">
        /// Argument that indicates the periodic value of a time series. If the value is null or
        /// is not present, the API determines the period automatically.
        /// </param>
        /// <param name="maxAnomalyRatio"> Argument that indicates an advanced model parameter. It's the maximum anomaly ratio in a time series. </param>
        /// <param name="sensitivity">
        /// Argument that indicates an advanced model parameter between 0 and 99. The lower the value
        /// is, the larger the margin value is, which means fewer anomalies will be
        /// accepted.
        /// </param>
        /// <param name="imputeMode">
        /// Specifies how to deal with missing values in the input series. It's used
        /// when granularity is not "none".
        /// </param>
        /// <param name="imputeFixedValue">
        /// Specifies the value to fill. It's used when granularity is not "none"
        /// and imputeMode is "fixed".
        /// </param>
        /// <returns> A new <see cref="AnomalyDetector.UnivariateDetectionOptions"/> instance for mocking. </returns>
        public static UnivariateDetectionOptions UnivariateDetectionOptions(IEnumerable<TimeSeriesPoint> series = default, TimeGranularity? granularity = default, int? customInterval = default, int? period = default, float? maxAnomalyRatio = default, int? sensitivity = default, ImputeMode? imputeMode = default, float? imputeFixedValue = default)
        {
            series ??= new ChangeTrackingList<TimeSeriesPoint>();

            return new UnivariateDetectionOptions(
                series.ToList(),
                granularity,
                customInterval,
                period,
                maxAnomalyRatio,
                sensitivity,
                imputeMode,
                imputeFixedValue,
                additionalBinaryDataProperties: null);
        }

        /// <summary> Definition of input time series points. </summary>
        /// <param name="timestamp"> Argument that indicates the time stamp of a data point (ISO8601 format). </param>
        /// <param name="value"> Measurement of that point. </param>
        /// <returns> A new <see cref="AnomalyDetector.TimeSeriesPoint"/> instance for mocking. </returns>
        public static TimeSeriesPoint TimeSeriesPoint(DateTimeOffset? timestamp = default, float value = default)
        {
            return new TimeSeriesPoint(timestamp, value, additionalBinaryDataProperties: null);
        }

        /// <summary> Response of the last anomaly detection. </summary>
        /// <param name="period">
        /// Frequency extracted from the series. Zero means no recurrent pattern has been
        /// found.
        /// </param>
        /// <param name="suggestedWindow"> Suggested input series points needed for detecting the latest point. </param>
        /// <param name="expectedValue"> Expected value of the latest point. </param>
        /// <param name="upperMargin">
        /// Upper margin of the latest point. UpperMargin is used to calculate
        /// upperBoundary, which is equal to expectedValue + (100 - marginScale)*upperMargin.
        /// If the value of latest point is between upperBoundary and lowerBoundary, it
        /// should be treated as a normal value. Adjusting the marginScale value enables the anomaly
        /// status of the latest point to be changed.
        /// </param>
        /// <param name="lowerMargin">
        /// Lower margin of the latest point. LowerMargin is used to calculate
        /// lowerBoundary, which is equal to expectedValue - (100 - marginScale)*lowerMargin.
        /// </param>
        /// <param name="isAnomaly">
        /// Anomaly status of the latest point. True means the latest point is an anomaly,
        /// either in the negative direction or in the positive direction.
        /// </param>
        /// <param name="isNegativeAnomaly">
        /// Anomaly status of the latest point in a negative direction. True means the latest
        /// point is an anomaly and its real value is smaller than the expected one.
        /// </param>
        /// <param name="isPositiveAnomaly">
        /// Anomaly status of the latest point in a positive direction. True means the latest
        /// point is an anomaly and its real value is larger than the expected one.
        /// </param>
        /// <param name="severity">
        /// Severity score for the last input point. The larger the value is, the more
        /// severe the anomaly is. For normal points, the severity is always 0.
        /// </param>
        /// <returns> A new <see cref="AnomalyDetector.UnivariateLastDetectionResult"/> instance for mocking. </returns>
        public static UnivariateLastDetectionResult UnivariateLastDetectionResult(int period = default, int suggestedWindow = default, float expectedValue = default, float upperMargin = default, float lowerMargin = default, bool isAnomaly = default, bool isNegativeAnomaly = default, bool isPositiveAnomaly = default, float? severity = default)
        {
            return new UnivariateLastDetectionResult(
                period,
                suggestedWindow,
                expectedValue,
                upperMargin,
                lowerMargin,
                isAnomaly,
                isNegativeAnomaly,
                isPositiveAnomaly,
                severity,
                additionalBinaryDataProperties: null);
        }

        /// <summary> Request of change point detection. </summary>
        /// <param name="series">
        /// Time series data points. Points should be sorted by time stamp in ascending
        /// order to match the change point detection result.
        /// </param>
        /// <param name="granularity"> Granularity is used to verify whether the input series is valid. </param>
        /// <param name="customInterval">
        /// A custom interval is used to set a nonstandard time interval. For example, if the
        /// series is 5 minutes, the request can be set as {"granularity":"minutely",
        /// "customInterval":5}.
        /// </param>
        /// <param name="period">
        /// Argument that indicates the periodic value of a time series. If the value is null or
        /// not present, the API will determine the period automatically.
        /// </param>
        /// <param name="stableTrendWindow">
        /// Argument that indicates an advanced model parameter. A default stableTrendWindow value will
        /// be used in detection.
        /// </param>
        /// <param name="threshold">
        /// Argument that indicates an advanced model parameter between 0.0 and 1.0. The lower the
        /// value is, the larger the trend error is, which means less change point will
        /// be accepted.
        /// </param>
        /// <returns> A new <see cref="AnomalyDetector.UnivariateChangePointDetectionOptions"/> instance for mocking. </returns>
        public static UnivariateChangePointDetectionOptions UnivariateChangePointDetectionOptions(IEnumerable<TimeSeriesPoint> series = default, TimeGranularity granularity = default, int? customInterval = default, int? period = default, int? stableTrendWindow = default, float? threshold = default)
        {
            series ??= new ChangeTrackingList<TimeSeriesPoint>();

            return new UnivariateChangePointDetectionOptions(
                series.ToList(),
                granularity,
                customInterval,
                period,
                stableTrendWindow,
                threshold,
                additionalBinaryDataProperties: null);
        }

        /// <summary> Response of change point detection. </summary>
        /// <param name="period">
        /// Frequency extracted from the series. Zero means no recurrent pattern has been
        /// found.
        /// </param>
        /// <param name="isChangePoint">
        /// Change point properties for each input point. True means
        /// an anomaly (either negative or positive) has been detected. The index of the
        /// array is consistent with the input series.
        /// </param>
        /// <param name="confidenceScores"> Change point confidence of each point. </param>
        /// <returns> A new <see cref="AnomalyDetector.UnivariateChangePointDetectionResult"/> instance for mocking. </returns>
        public static UnivariateChangePointDetectionResult UnivariateChangePointDetectionResult(int? period = default, IEnumerable<bool> isChangePoint = default, IEnumerable<float> confidenceScores = default)
        {
            isChangePoint ??= new ChangeTrackingList<bool>();
            confidenceScores ??= new ChangeTrackingList<float>();

            return new UnivariateChangePointDetectionResult(period, isChangePoint.ToList(), confidenceScores.ToList(), additionalBinaryDataProperties: null);
        }

        /// <summary> Detection results for the resultId value. </summary>
        /// <param name="resultId"> Result identifier that's used to fetch the results of an inference call. </param>
        /// <param name="summary"> Multivariate anomaly detection status. </param>
        /// <param name="results"> Detection result for each time stamp. </param>
        /// <returns> A new <see cref="AnomalyDetector.MultivariateDetectionResult"/> instance for mocking. </returns>
        public static MultivariateDetectionResult MultivariateDetectionResult(Guid resultId = default, MultivariateBatchDetectionResultSummary summary = default, IEnumerable<AnomalyState> results = default)
        {
            results ??= new ChangeTrackingList<AnomalyState>();

            return new MultivariateDetectionResult(resultId, summary, results.ToList(), additionalBinaryDataProperties: null);
        }

        /// <summary> Multivariate anomaly detection status. </summary>
        /// <param name="status"> Status of detection results. </param>
        /// <param name="errors"> Error message when detection fails. </param>
        /// <param name="variableStates"> Variable status. </param>
        /// <param name="setupInfo">
        /// Detection request for batch inference. This is an asynchronous inference that
        /// will need another API to get detection results.
        /// </param>
        /// <returns> A new <see cref="AnomalyDetector.MultivariateBatchDetectionResultSummary"/> instance for mocking. </returns>
        public static MultivariateBatchDetectionResultSummary MultivariateBatchDetectionResultSummary(MultivariateBatchDetectionStatus status = default, IEnumerable<ErrorResponse> errors = default, IEnumerable<VariableState> variableStates = default, MultivariateBatchDetectionOptions setupInfo = default)
        {
            errors ??= new ChangeTrackingList<ErrorResponse>();
            variableStates ??= new ChangeTrackingList<VariableState>();

            return new MultivariateBatchDetectionResultSummary(status, errors.ToList(), variableStates.ToList(), setupInfo, additionalBinaryDataProperties: null);
        }

        /// <summary> Error information that the API returned. </summary>
        /// <param name="code"> Error code. </param>
        /// <param name="message"> Message that explains the error that the service reported. </param>
        /// <returns> A new <see cref="AnomalyDetector.ErrorResponse"/> instance for mocking. </returns>
        public static ErrorResponse ErrorResponse(string code = default, string message = default)
        {
            return new ErrorResponse(code, message, additionalBinaryDataProperties: null);
        }

        /// <summary> Variable status. </summary>
        /// <param name="variable"> Variable name in variable states. </param>
        /// <param name="filledNARatio"> Proportion of missing values that need to be filled by fillNAMethod. </param>
        /// <param name="effectiveCount"> Number of effective data points before fillNAMethod is applied. </param>
        /// <param name="firstTimestamp"> First valid time stamp with a value of input data. </param>
        /// <param name="lastTimestamp"> Last valid time stamp with a value of input data. </param>
        /// <returns> A new <see cref="AnomalyDetector.VariableState"/> instance for mocking. </returns>
        public static VariableState VariableState(string variable = default, float? filledNARatio = default, int? effectiveCount = default, DateTimeOffset? firstTimestamp = default, DateTimeOffset? lastTimestamp = default)
        {
            return new VariableState(
                variable,
                filledNARatio,
                effectiveCount,
                firstTimestamp,
                lastTimestamp,
                additionalBinaryDataProperties: null);
        }

        /// <summary>
        /// Detection request for batch inference. This is an asynchronous inference that
        /// will need another API to get detection results.
        /// </summary>
        /// <param name="dataSource">
        /// Source link to the input data to indicate an accessible Azure Storage URI.
        /// It either points to an Azure Blob Storage folder or points to a CSV file in
        /// Azure Blob Storage, based on your data schema selection. The data schema should
        /// be exactly the same as those used in the training phase. The input data must
        /// contain at least slidingWindow entries preceding the start time of the data
        /// to be detected.
        /// </param>
        /// <param name="topContributorCount"> Number of top contributed variables for one anomalous time stamp in the response. </param>
        /// <param name="startTime">
        /// Start date/time of data for detection, which should
        /// be in ISO 8601 format.
        /// </param>
        /// <param name="endTime">
        /// End date/time of data for detection, which should
        /// be in ISO 8601 format.
        /// </param>
        /// <returns> A new <see cref="AnomalyDetector.MultivariateBatchDetectionOptions"/> instance for mocking. </returns>
        public static MultivariateBatchDetectionOptions MultivariateBatchDetectionOptions(Uri dataSource = default, int? topContributorCount = default, DateTimeOffset startTime = default, DateTimeOffset endTime = default)
        {
            return new MultivariateBatchDetectionOptions(dataSource, topContributorCount, startTime, endTime, additionalBinaryDataProperties: null);
        }

        /// <summary> Anomaly status and information. </summary>
        /// <param name="timestamp"> Time stamp for this anomaly. </param>
        /// <param name="value"> Detailed value of this anomalous time stamp. </param>
        /// <param name="errors"> Error message for the current time stamp. </param>
        /// <returns> A new <see cref="AnomalyDetector.AnomalyState"/> instance for mocking. </returns>
        public static AnomalyState AnomalyState(DateTimeOffset timestamp = default, AnomalyValue value = default, IEnumerable<ErrorResponse> errors = default)
        {
            errors ??= new ChangeTrackingList<ErrorResponse>();

            return new AnomalyState(timestamp, value, errors.ToList(), additionalBinaryDataProperties: null);
        }

        /// <summary> Detailed information of the anomalous time stamp. </summary>
        /// <param name="isAnomaly"> True if an anomaly is detected at the current time stamp. </param>
        /// <param name="severity">
        /// Indicates the significance of the anomaly. The higher the severity, the more
        /// significant the anomaly is.
        /// </param>
        /// <param name="score"> Raw anomaly score of severity, to help indicate the degree of abnormality. </param>
        /// <param name="interpretation"> Interpretation of this anomalous time stamp. </param>
        /// <returns> A new <see cref="AnomalyDetector.AnomalyValue"/> instance for mocking. </returns>
        public static AnomalyValue AnomalyValue(bool isAnomaly = default, float severity = default, float score = default, IEnumerable<AnomalyInterpretation> interpretation = default)
        {
            interpretation ??= new ChangeTrackingList<AnomalyInterpretation>();

            return new AnomalyValue(isAnomaly, severity, score, interpretation.ToList(), additionalBinaryDataProperties: null);
        }

        /// <summary> Interpretation of the anomalous time stamp. </summary>
        /// <param name="variable"> Variable. </param>
        /// <param name="contributionScore">
        /// This score shows the percentage that contributes to the anomalous time stamp. It's a
        /// number between 0 and 1.
        /// </param>
        /// <param name="correlationChanges"> Correlation changes among the anomalous variables. </param>
        /// <returns> A new <see cref="AnomalyDetector.AnomalyInterpretation"/> instance for mocking. </returns>
        public static AnomalyInterpretation AnomalyInterpretation(string variable = default, float? contributionScore = default, CorrelationChanges correlationChanges = default)
        {
            return new AnomalyInterpretation(variable, contributionScore, correlationChanges, additionalBinaryDataProperties: null);
        }

        /// <summary> Correlation changes among the anomalous variables. </summary>
        /// <param name="changedVariables"> Correlated variables that have correlation changes under an anomaly. </param>
        /// <returns> A new <see cref="AnomalyDetector.CorrelationChanges"/> instance for mocking. </returns>
        public static CorrelationChanges CorrelationChanges(IEnumerable<string> changedVariables = default)
        {
            changedVariables ??= new ChangeTrackingList<string>();

            return new CorrelationChanges(changedVariables.ToList(), additionalBinaryDataProperties: null);
        }

        /// <summary>
        /// Training result of a model, including its status, errors, and diagnostics
        /// information.
        /// </summary>
        /// <param name="dataSource">
        /// Source link to the input data to indicate an accessible Azure Storage URI.
        /// It either points to an Azure Blob Storage folder or points to a CSV file in
        /// Azure Blob Storage, based on your data schema selection.
        /// </param>
        /// <param name="dataSchema">
        /// Data schema of the input data source. The default
        /// is OneTable.
        /// </param>
        /// <param name="startTime">
        /// Start date/time of training data, which should be
        /// in ISO 8601 format.
        /// </param>
        /// <param name="endTime">
        /// End date/time of training data, which should be
        /// in ISO 8601 format.
        /// </param>
        /// <param name="displayName">
        /// Display name of the model. Maximum length is 24
        /// characters.
        /// </param>
        /// <param name="slidingWindow">
        /// Number of previous time stamps that will be used to
        /// detect whether the time stamp is an anomaly or not.
        /// </param>
        /// <param name="alignPolicy"> Manner of aligning multiple variables. </param>
        /// <param name="status"> Model status. </param>
        /// <param name="errors"> Error messages after failure to create a model. </param>
        /// <param name="diagnosticsInfo"> Diagnostics information to help inspect the states of a model or variable. </param>
        /// <returns> A new <see cref="AnomalyDetector.ModelInfo"/> instance for mocking. </returns>
        public static ModelInfo ModelInfo(Uri dataSource = default, DataSchema? dataSchema = default, DateTimeOffset startTime = default, DateTimeOffset endTime = default, string displayName = default, int? slidingWindow = default, AlignPolicy alignPolicy = default, ModelStatus? status = default, IEnumerable<ErrorResponse> errors = default, DiagnosticsInfo diagnosticsInfo = default)
        {
            errors ??= new ChangeTrackingList<ErrorResponse>();

            return new ModelInfo(
                dataSource,
                dataSchema,
                startTime,
                endTime,
                displayName,
                slidingWindow,
                alignPolicy,
                status,
                errors.ToList(),
                diagnosticsInfo,
                additionalBinaryDataProperties: null);
        }

        /// <summary> Manner of aligning multiple variables. </summary>
        /// <param name="alignMode">
        /// Field that indicates how to align different variables to the same
        /// time range.
        /// </param>
        /// <param name="fillNAMethod"> Field that indicates how missing values will be filled. </param>
        /// <param name="paddingValue"> Field that's required when fillNAMethod is Fixed. </param>
        /// <returns> A new <see cref="AnomalyDetector.AlignPolicy"/> instance for mocking. </returns>
        public static AlignPolicy AlignPolicy(AlignMode? alignMode = default, FillNAMethod? fillNAMethod = default, float? paddingValue = default)
        {
            return new AlignPolicy(alignMode, fillNAMethod, paddingValue, additionalBinaryDataProperties: null);
        }

        /// <summary> Diagnostics information to help inspect the states of a model or variable. </summary>
        /// <param name="modelState"> Model status. </param>
        /// <param name="variableStates"> Variable status. </param>
        /// <returns> A new <see cref="AnomalyDetector.DiagnosticsInfo"/> instance for mocking. </returns>
        public static DiagnosticsInfo DiagnosticsInfo(ModelState modelState = default, IEnumerable<VariableState> variableStates = default)
        {
            variableStates ??= new ChangeTrackingList<VariableState>();

            return new DiagnosticsInfo(modelState, variableStates.ToList(), additionalBinaryDataProperties: null);
        }

        /// <summary> Model status. </summary>
        /// <param name="epochIds">
        /// Number of passes of the entire training dataset that the
        /// algorithm has completed.
        /// </param>
        /// <param name="trainLosses">
        /// List of metrics used to assess how the model fits the training data for each
        /// epoch.
        /// </param>
        /// <param name="validationLosses">
        /// List of metrics used to assess how the model fits the validation set for each
        /// epoch.
        /// </param>
        /// <param name="latenciesInSeconds"> Latency for each epoch. </param>
        /// <returns> A new <see cref="AnomalyDetector.ModelState"/> instance for mocking. </returns>
        public static ModelState ModelState(IEnumerable<int> epochIds = default, IEnumerable<float> trainLosses = default, IEnumerable<float> validationLosses = default, IEnumerable<float> latenciesInSeconds = default)
        {
            epochIds ??= new ChangeTrackingList<int>();
            trainLosses ??= new ChangeTrackingList<float>();
            validationLosses ??= new ChangeTrackingList<float>();
            latenciesInSeconds ??= new ChangeTrackingList<float>();

            return new ModelState(epochIds.ToList(), trainLosses.ToList(), validationLosses.ToList(), latenciesInSeconds.ToList(), additionalBinaryDataProperties: null);
        }

        /// <summary> Response of getting a model. </summary>
        /// <param name="modelId"> Model identifier. </param>
        /// <param name="createdTime"> Date and time (UTC) when the model was created. </param>
        /// <param name="lastUpdatedTime"> Date and time (UTC) when the model was last updated. </param>
        /// <param name="modelInfo">
        /// Training result of a model, including its status, errors, and diagnostics
        /// information.
        /// </param>
        /// <returns> A new <see cref="AnomalyDetector.AnomalyDetectionModel"/> instance for mocking. </returns>
        public static AnomalyDetectionModel AnomalyDetectionModel(Guid modelId = default, DateTimeOffset createdTime = default, DateTimeOffset lastUpdatedTime = default, ModelInfo modelInfo = default)
        {
            return new AnomalyDetectionModel(modelId, createdTime, lastUpdatedTime, modelInfo, additionalBinaryDataProperties: null);
        }

        /// <summary> Request of the last detection. </summary>
        /// <param name="variables">
        /// Contains the inference data, including the name, time stamps (ISO 8601), and
        /// values of variables.
        /// </param>
        /// <param name="topContributorCount">
        /// Number of top contributed
        /// variables for one anomalous time stamp in the response. The default is
        /// 10.
        /// </param>
        /// <returns> A new <see cref="AnomalyDetector.MultivariateLastDetectionOptions"/> instance for mocking. </returns>
        public static MultivariateLastDetectionOptions MultivariateLastDetectionOptions(IEnumerable<VariableValues> variables = default, int? topContributorCount = default)
        {
            variables ??= new ChangeTrackingList<VariableValues>();

            return new MultivariateLastDetectionOptions(variables.ToList(), topContributorCount, additionalBinaryDataProperties: null);
        }

        /// <summary> Variable values. </summary>
        /// <param name="variable"> Variable name of the last detection request. </param>
        /// <param name="timestamps"> Time stamps of the last detection request. </param>
        /// <param name="values"> Values of variables. </param>
        /// <returns> A new <see cref="AnomalyDetector.VariableValues"/> instance for mocking. </returns>
        public static VariableValues VariableValues(string variable = default, IEnumerable<string> timestamps = default, IEnumerable<float> values = default)
        {
            timestamps ??= new ChangeTrackingList<string>();
            values ??= new ChangeTrackingList<float>();

            return new VariableValues(variable, timestamps.ToList(), values.ToList(), additionalBinaryDataProperties: null);
        }

        /// <summary> Results of the last detection. </summary>
        /// <param name="variableStates"> Variable status. </param>
        /// <param name="results"> Anomaly status and information. </param>
        /// <returns> A new <see cref="AnomalyDetector.MultivariateLastDetectionResult"/> instance for mocking. </returns>
        public static MultivariateLastDetectionResult MultivariateLastDetectionResult(IEnumerable<VariableState> variableStates = default, IEnumerable<AnomalyState> results = default)
        {
            variableStates ??= new ChangeTrackingList<VariableState>();
            results ??= new ChangeTrackingList<AnomalyState>();

            return new MultivariateLastDetectionResult(variableStates.ToList(), results.ToList(), additionalBinaryDataProperties: null);
        }
    }
}
